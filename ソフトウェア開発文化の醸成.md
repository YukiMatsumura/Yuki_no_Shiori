### チーム開発実践入門

#### 1.1 一人だけでも開発はできる

ソフトウェアは一人でも開発できる. 一人で開発する分にはコミュニケーションコストがかからず,
とてもスピーディに開発・リリースすることができる.
ソフトウェアの規模が小さければすべてを一人だけで把握することが可能だ.

ただし, ソフトウェアの規模がある水準を超えると, 製品のすべてを一人だけで把握することが難しくなり, 複数の人たちによるチームで開発する必要が出てくる.

#### 1.2 チーム開発で直面する課題

チーム開発を進めていくと, さまざまな問題に直面する.
課題をチーム間で適切に共有できない, 進捗が見えにくい, 開発内容（コード）の競合,
コード品質の均一化, 製品コード全容の把握, など.

また, ソフトウェア開発では一度リリースしたらそれで開発が終わりではない.
長期にわたってアップデートなどを繰り返しながら運用することが多い.
その長い期間, 一人では把握できないサイズのコードを複数の人たちで並行して変更しながら品質を一定に保ち, デグレードを起こさずに, 同時に新機能を追加していかなければならない.

人間は間違えかつ忘れる生き物である.
ちょっとしたミスでデグレードを起こす. また複雑なソフトウェアの全容を把握してもれなくテストを実行することもできない.
自分の書いたコードも数ヶ月で忘れてしまう.

#### 1.3 どのように課題に立ち向かうか

複数の人たちで課題を共有し, 何が起きているかをわかりやすくオープンにし, デグレードが起きないようにテストを自動化することが重要で, かつ何かを間違った時にはすぐに元に戻れるのも大切.
また一方で新機能をスピーディに開発しリリースできないと市場競争で負けてしまうため, 並行して複数の機能を開発しないといけない. もちろん品質を保ったまま.

つまり以下のことがチーム開発を円滑に進めるために必要である.

 - 「何を」「いつまでに」「誰が」実行するのか、「何が」できたら「完了」なのかを管理・共有すること
 - ソースコードを始めとする成果物をチームで共有すること
 - 成果物の変更を管理し、成果物が壊れないように保ちつつ、各メンバーが並行作業できるようにすること
 - プロジェクトで得られた知識をチーム間で共有すること
 - チームで開発したソフトウェアがいつでも正しく動作することを証明すること
 - 誰がやっても間違いなく開発・テスト・リリースができるように作業を自動化すること

#### 1.5 最適なプラクティスはケースバイケース

どこにでも通用する万能のベストプラクティスはない.
状況に応じたベターなパターンの組み合わせが何通りもあるのが正解に近い.
実際に自分が関わるプロジェクトに応じた最適解を見出せるかどうかがプロジェクトを成功に導く鍵と言える.


### 2.1 ケーススタディの前提

チーム開発を効率的に進めるためのさまざまなツールや方法論が巷に溢れている.

ツール

 - バージョン管理システム（Version Control System : VCS）
 - チケット管理システム（Issue Tracking System, Bug Tracking System : ITS/BTS）

方法論

 - 継続的インテグレーション（Continuous Integration : CI）
 - 継続的デリバリ（Continuous Delivery : CD）

これらのツールや方法論はなぜ必要なのか.
それを知るには「こららのツールや方法論を用いないと, プロジェクトはいったいどうなってしまうのか」を知っておく必要がある.
下記はデスマーチに陥ったプロジェクトの2日間をケーススタディとして,
プロジェクトで起こりがちな現象を見ていき, その後何が問題だったのかを振り返っている.

#### 2.2 ケーススタディ（1日目）

##### 問題１：重要なメールが多すぎて優先順位を決められない

出社すると, 【重要】【至急】【即対応】といったラベル付きのメールが複数件ある.
何から手をつけて良いのかわからない. とりあえず受け取ったメールを端から読んで対応しよう...

##### 問題２：検証環境がない

メールで報告された現象を確認するために本番環境と同じ環境を構築することから始めよう...
だがこのプロジェクトには検証環境がそもそも用意されていない.
本番環境で起きた問題を手元で再現するには, 本番環境と同じ環境を再現する必要がある.

##### 問題３：別名フォルダでブランチを管理している

昨日まで新機能を開発していたため, 自分のローカルマシンにあるソースコードは本番環境とかけ離れている.
ローカルマシンにある開発中のソースコードを"xxx_new"のようにフォルダごとリネームしておき,
バージョン管理システムから最新のソースコードをチェックアウトしてくる.  
バージョン管理システム上の最新コードと本番環境用のコードには差異がある可能性もある.  
プロジェクトにバージョン管理システムに精通したメンバーはいない...  

image: 開発作業用フォルダ
 Dev
  | - LocalApp
  | - LocalApp_New(最新)
  | - LocalApp_Honban(本番コピー)

##### 問題４：データベースの再生性が困難

バージョン管理システム上のスキーマと本番環境スキーマは異なっている.  
しかし, どのようにSQLを適用すれば良いのかわからない.  
ともかく空気を読んで適当にSQLを適用してなんとかそれっぽいものを構築した.  
本番環境と同じ状態を再現できたかどうかはわからない...  
データベースのスキーマを定義できたので本番環境と同じデータを投入してみる. が失敗した.  
何度かトライしたらうまくいった. データベースのスキーマ定義が間違っていたようだ...  

ともかくデータベースの準備ができたので再現確認を試みる. が, 再現しない.  
諦めて本番環境にあるデータベースを丸ごとそのまま開発環境にコピーした.    

気がつくともうお昼の時間だ. ここまでで3時間以上かかった.  
しかし, メールで報告された現象の再現確認すらまだできていない...  
その日の午後は同僚と手分けして, なんとか朝に来ていた4件のメールの内容を全て再現し,
1日がかりでバグ修正して4件すべてバージョン管理システムにコミットした.  

本来やるべきだった新機能の開発には着手すらできなかった. もう終電なので帰ろう... 明日, 頑張ろう...  
#### 2.3 ケーススタディ（1日目）における問題点

##### 問題１：重要なメールが多すぎて優先順位を決められない

プロジェクトには課題を管理するしくみ（チケット管理システム）がないため, バグや障害報告もメールで送られてくる.  
メールの件名には【重要】【至急】などのラベルがついており, すべてが重要扱いであるため何から着手するのが正しいのかわからない.  

メールだけでやりとりするプロジェクトの問題

 - メールの件数が多く, 重要なメールが埋もれてしまう
 - 課題ステータスの管理ができない
 - 一覧性, 検索性が弱い

メールはプロジェクトを管理するツールとしてはあまりに機能不足である.  
プロジェクトが混乱している時, 原因はいくつかの問題に起因するが, 大きな問題の一つがここで挙げたような情報共有, 課題の効率的な管理のしくみがないことに集約される.  

こういった問題を解決するにはチケット管理システムの導入を検討するとよい.  

##### 問題２：検証用環境がない

本番環境での障害報告を受けてからソースコードをかき集めて開発環境に再構築していてはその都度時間がかかってしまう.  
新規案件開発中に本番環境で起きた障害を調査しないといけないこともある.  
常に本番環境と同じ環境を再現できるステージング環境を持つことで効率化できる.  

##### 問題３：別名フォルダでブランチを管理する

バージョン管理システムを導入していても効果的に使わなければ効果が薄れる.  
バージョン管理システムを使う目的は, いつ, 誰が, どう変更したのか, の履歴を管理することと,  
いつでも戻りたいときに過去のある時点の状態にもどれるようにすること（ブランチ, タグの管理）です.  
このプロジェクトでは, バージョン管理システムの重要な機能であるブランチやタグといった機能を使いこなせていない.  

##### 問題４：データベースの再作成が困難

このプロジェクトではSQLファイルをバージョン管理システムで管理するところまではやっていた.  
ここでよく起こる問題は, SQLをどの環境にどこまで適用しているのか側からず, 適用漏れに気づかないという問題である.  
また, 複数人でデータベースを変更している場合に矛盾なく管理する方法を検討する必要がある.  

ポイントはデータベースの構築手順が確立されていないこと.  
これでは正しい挙動を保証できる環境をうまく作れない.  

テスト環境を用意して運用するには少なくないコストがかかる.  
そのためプロジェクトの予算が許す範囲で最適な環境構築を行うことが重要である.  

#### 2.4 ケーススタディ（２日目）

##### 問題５：起動するまで壊れていることに気づかない

昨日のコミットで１件修正されていないという報告があった. さらにデグレードまで起こしてしまった.  
昨日は全員のコミットを一箇所に集めて組み合わせて動作確認はしていなかったのだ.  
また, 過去発生していた不具合の再発報告も合わせて見つかった.

##### 問題６：他メンバーの修正を上書きして消してしまう

バージョン管理システムでコンフリクトが発生したものの強制的に上書きしてしまった.  
これによって過去の不具合改修コードが上書きされてしまい, デグレが発生した.  

##### 問題７：自信を持ってリファクタリングできない

問題を修正したがifの条件文が変わっているので動作が変わりそうであった.  
リファクタリングをしたほうが良さそうな例であったが, デグレードが起きない自信がなく仕方なくif文を追加する形で対応した.  

##### 問題８：バグの修正時期がわからず, デグレードも追跡できない

再発した過去の不具合とはどのようなものなのか, いつ起こったのか.  
発生日を調べてバージョン管理システムのリポジトリから該当のリビジョンを探す.  
結果, ３ヶ月ほど前の別の修正リリースが原因でデグレードが起きているようだった.  
修正をコミットする. 昨日修正した4件のバグ修正のリグレッションも忘れてはいけない.  

##### 問題９：ブランチ・タグを活用できていない

ようやく, 本番環境の不具合対応も落ち着いたので新機能の開発に戻る.  
昨日リネームしておいたフォルダを使って開発を再開する.  
しかし, このフォルダには２日間かけて対応したバグ修正が入っていない.  
リネームしておいたフォルダのままコミットしたら, また盛大にデグレードが起きてしまう...  

##### 問題１０：テスト環境や本番環境では動かない

新機能の開発を進めていたところ, テスト担当から昨日のコミットがステージング環境だと動かない旨の連絡がきた.  
ステージング環境を確認したところ, デグレードの件もすべてうまく修正されていることを確認できた.  
試しに, ローカルマシン上にステージング環境のコードをコピーして（もちろん新機能開発環境は別フォルダにコピーして）確認環境を構築する.  
ローカルマシン上で動作確認したところ不具合の現象は再現しない.  
そこで, 昨日のバグ修正のさいに新しいライブラリを追加していたことを思い出す.  
ステージング環境では新しいライブラリがインストールされていなかったのだ.  

##### 問題１１：リリースが複雑で手順書が必要

本番環境へリリースする際に, トラブル回避のためリリース担当からリリース手順書の提出を求められた.  
今回のリリースは重大なバグを含むため, 開発者の同席は仕方がない.  
リリースは夜通し行わる. 今夜は家に帰れそうもない...  

手順書を確認しながら, ステージング環境と本番環境の違いに注意して設定ファイルを編集しながら,
慎重に目視で確認しながらマージする.  
こういった作業はバージョン管理システムには残らない.
おそらく次のリリースの際にも同じことが起こりそうだ.  

このようにしてデスマーチは続いていく.

#### 2.5 ケーススタディ（２日目）における問題点

##### 問題５：起動するまで壊れていることに気づかない

修正コミットを上書きして消してしまったことが問題の原因である.  
バージョン管理システムのコミットログを丹念に追跡すればこの原因を突き止めることは不可能ではない.  
だが, ここでの問題はその問題に気付くのに一昼夜かかっていることにある.  

仮に数ヶ月前の修正によるデグレードだとした場合, コミットログを追跡して原因を突き止めるのにどれほどの時間が必要になるだろうか...  
もっと早くこの間違いに気付くことはできないのか.  

例えば, バージョン管理システムに変更をコミットするたびに, アプリケーション全体が正しくビルドできているか, 過去分の動作を保証できているかをチェックできたらよいのではないか.  
このような考え方をCI（継続的インてグレーション）と呼ぶ.  

##### 問題６：他メンバーの修正を上書きして消してしまう

複数人でアプリケーションを開発していると, 修正箇所が重なってコンフリクトが起きることもある.  
コンフリクトが発生したときには, 双方の修正が正しく動作するようにマージする必要があるが,
これを正しく行うのは大変なことだ.  
また, 各メーンバーがマージをしてくれるかどうかも保証がない.  

これにはマージでコンフリクト解消を思想とするSubversionやGitが使える.  

##### 問題７：自信を持ってリファクタリングできない

メンバーによってバグ修正コミットが上書きされて消えてしまった.  
どのように修正するのが最もスマートなのかは頭を悩ませる.  
複数人での開発において, 修正箇所にコンフリクトが発生するのは, 同じ箇所を違う目的でコードを追加しているからだ.  
なんらかの形でコードの構成を見直すべきで, リファクタリングが必要であることを示唆している.  

リファクタリングは「外部から見た動作を変えず」ソースコードの内部構造を整理することである.  
リファクタリングは外部から見た動作が変わっていないことを保証する必要がある.  
つまり, 何がそのプログラムにおいて「正しさ」なのかを定義する必要がある.  

１つの方法として, 仕様書などのドキュメントを用意する方法がある.  
「正しさ」を証明する方法としては良いのだが, リファクタリングを行ったプログラムが仕様書通りに動いているかを毎回手動で確認するのはとても時間がかかる.  

また, 時間がかかる, 面倒すぎるなどの思いが頭をよぎると, リファクタリング自体を行う心理的障壁が高くなってしまい, 手が動かなくなりがちである.  
このような障壁を取り除き, 自信を持ってリファクタリングを行うためには, テストコードを書くことが重要である.  
リファクタリングとは「プログラムの外部から見た目を変えずにソースコードを整理すること」
なのだから, 外部から見た動作が変わっていないことを保証するテストコードを書けばよい.  
実行可能で, 繰り返し使えるテストコードは「正しさ」をいつでもすぐに確認できるようになる.  
そのような環境が整って初めて, 思い切ったリファクタリングにとりかかることができる.  

テストコードがあればリファクタリングを行う心理的障壁は劇的に下がる.  
リファクタリングをしてバージョン管理システムのリポジトリにコミットする前にコマンド１つで「正しさ」を確認できるため, 何か間違ったリファクタリングをしてしまった場合もコミット前に気付くことができる.  

さらに, CIを導入して, テストコードを常時自動実行できるようにする.  
「正しさ」を検証する機会が増え, 安心してリファクタリングできる.  
ローカルマシンでテストパスしても, 他のメンバーの変更と統合するとテストフェールする場合もある.  

開発者は人間なので, コミット前にテストを実行することを忘れることもある.  
CIを導入すれば, CIサーバが自動的にテストを実行してくれるため, 間違いに気付くことができる.  

逆にテストコードも書かず, CIも行わず, さらにリファクタリングも行われずにメンテナンスされ続けたコードは, 大きな負債となってビジネスの成長を阻害することがある.  
「レガシーコード改善ガイド」ではこれを"レガシーコード"として定義している.  

「正しさ」を確認する手段が手動と目視によるテストだけ, という状態では, 「正しさ」の確認にいたずらに時間がかかってしまい, リグレッションテストの実行が現実的ではなくなる.  
さらにレガシーコードを生み出す悪循環に陥ってしまい, 一向に品質は上がらない.  

##### 問題８：バグの修正時期がわからず, デグレードも追跡できない

過去のバグが復活するケースがありました.  
また, どのようなバグで, どのコミットで直したのかがわからないという話は長いプロジェクトではよくある話かもしれない.  
メールや口頭だけでのみ情報共有していると, こういったことが起こりがちになる.  
解決方法としては, チケット管理システムとバージョン管理システムを連動させて, ソースコードの変更履歴とチケットを関連付けて記録する方法がある.

さらに, CIとITS/BTS, バージョン管理システムを組み合わせれば, ある課題がいつ, 誰によって, どのように変更されたのか, そして結果としてそれはテストを通過したのか, さらにそれはステージング環境へデプロイされているのか, 本番環境にリリースされたのかまでを追跡することが可能になる.  

##### 問題９：ブランチ・タグを活用できていない

不具合修正したあと, 新機能開発に戻ると不具合修正内容のマージを忘れていた.  
バージョン管理の機能であるブランチ、タグをうまく使いこなせていたいために起きている.  
バージョン管理ツールを使って, 複数の作業を効率良く並行して行うことができる.  

##### 問題１０：テスト環境や本番環境ではうごかない

ローカルマシンでは動いても, ステージング環境や本番環境で動かないことはよくある.  
こういった環境依存の問題は多くある.  

 - データベースのスキーマの差異による問題
 - アプリケーションが依存するライブラリのインストール漏れなどの問題
 - httpdやmemchachedのような環境によって設定が変わる各種ミドルウェアの問題

こういった環境依存の問題を解決するツールが出ている.  

##### 問題１１：リリースが複雑で手順書が必要となる

本番環境へのリリースは複雑で緊張を伴う.  
数百行に及ぶ手順書を複数の人たちでダブルチェック, トリプルチェックして慎重にリリースしてもたいていスムーズにはいかない.  
障害対応で手順書に膨大なチェックリストを追加したり, チェックする人数を増やしたりすることで, さらに業務は複雑化してしまう.  

人気のあるWebサービスの多くは, 凄まじい勢いでバグを直して新機能を追加している.  
1日あたりに100回以上のリリースをするサービスもあり, そのような驚異的なスピードでリリースしているサービスは少なくとも手順書を使って人手を介してリリースしているわけではなさそうだ.  

作業手順を簡素化できれば, 作業ミスも減る.  
これを実現するには, 環境依存の問題をコントロールできるようにし, 自動テスト, 自動デプロイを可能にする必要がある.  
言い換えれば「いつでもリリース可能」な状態を継続的に維持しておくことが重要である.  
このような考え方を継続的デリバリー（CD）と呼ぶ.  
CDはハードルが高いプラクティスだが, 実現すると開発チームのアジリティは飛躍的に高まる.  

(図2.7 理想的な開発フロー例)


#### 3.1 バージョン管理システム

バージョン管理システムを使うメリット

 - 変更内容という最も基本的な記録が残る
 - バージョン間の差分を簡単に確認できる
 - 間違って他人の変更を上書きしないで済むしくみがある
 - 任意の時点まで巻き戻すことができる
 - 複数の派生を作ることができる、ある時点での断面を保存できる

バージョン管理システムで管理すべきもの  

 - ソースコード
 - 要件書, 設計書などのドキュメント
 - データベーススキーマ, データ
 - ミドルウェアなどの設定ファイル
 - ライブラリなどの依存関係の定義

可能であればドキュメントもテキスト形式で管理することを検討する.  

#### 3.6 Gitを使った開発フロー

##### Gitを使ったワークフローのパターン

Gitを使ったワークフローには大きく次のようなパターンがある.  

 - 中央集権型ワークフロー
 - GitHub型ワークフロー

##### 中央集権型ワークフロー

従来のSubversionのように, 中央リポジトリを1つ設定し,
開発メンバー全員がそれを唯一のPush/Pull先としてローカルマシンにクローンするフロー.  
Subversionの考え方をそれほど変えなくて良いメリットがある.  
また, git-svnというツールによって, 中央リポジトリを実際にSubversionそのものにする方法もある.  

##### GitHub型ワークフロー

統合マネージャ型のワークフローと名付けられていることも.  
GitHubとほぼ同じフローで, 開発メンバーは中央リポジトリをForkしたリモートリポジトリを持ち,  
それをローカルマシンにクローンするフロー.  
普段の開発では, Forkした自分専用のリモートリポジトリにPushしておき,
ある程度固まったタイミングで中央リポジトリのメンテなにPullをお願いする方式.  

##### ブランチ戦略のパターン

git-flow
2010年にVincent Driessen氏によって書かれた『A successful Git branching model』というブログ記事で提案されたブランチ戦略.  
整理されたブランチ戦略でGit拡張スクリプト（git-flow script）が提供されている.  
問題点は運用が複雑になり, 覚えないといけないことが多く, git-flowで用意されたgit-flow scriptがないと運用が難しい.  
Git自体が決してやさしくないのに, ブランチ戦略も理解しないといけない.  
GUIツールで作業した場合は, git-flowスクリプトの恩恵にあやかれない（SourceTreeは対応）.  

github-flow
『Pro Git』の著者でGitHubのオフィサーでもあるScott Chacon氏が、GitHubのフローとしてブログで発表したもの.  

 - masterのものは全てリリース可能
 - 新しく何かを作るときはmasterから直接ブランチを作る
 - 作成したブランチはローカルマシンにコミットして, リモートリポジトリにも同じ名前のブランチとして定期的にPushする
 - 開発が完了したらmasterへPullRequestを送る
 - PullRequestがレビューされたらmasterにマージし, その場で本番環境にリリースする.

PullRequestの内容をテストするCI/自動テスト環境を常時稼働していることが前提になってくる.  
やや敷居の高い方法である.  
