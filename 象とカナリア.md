プロジェクトの規模が大きくなるにつれ, ソフトウェアの複雑さは増していきます.

今回はソフトウェア開発の難題 "壊さずに変更すること" について話します.


新しいプロジェクトが開始されました. チームのメンバーは皆プロジェクトの成功を信じて明るい未来を見ています.

顧客から"いつもの"仕様変更を依頼されても快く受け入れて, 全てが楽勝です.

イテレーションは進み, ソフトウェアも形になってきました.

チームは思い付いた良いアイディアを試そうとするメンバーがいる程に活発です.

全てが順調に進んでいます. 何も恐れるものがない理想的な状態です.


更にイテレーションは進み数週間が過ぎた頃.

チームは以前の活気を失い, 良いアイディアを試そうとするメンバーも今はいなくなりました.

顧客からの"いつもの"仕様変更に対しては何かと理由をつけて断り, 隠しごとが増える一方です.

チームに何が起こったのでしょうか？


順調であったチームに新たな参加者が増えたのです.

参加者は"既に書いたソフトウェア"という名の象です. 象は日を追う毎に大きくなります.

今や, この大きな象が私たちを完全に支配しているのです.

新しいアイディアや仕様変更がある度, 大きな象に今までとは違うより良いことや,

新しいことをやらせるわけです. 大きな象を押して動かす必要があるのです. 


伝えたいことは, ソフトウェアが複雑になると私たちは完全に支配されてしまうということです.

どんなに素晴らしい開発プロセスやテストを用意しても複雑さという象が私たちにできることを完全に支配してしまいます.


私たちは, "大きな象"に立ち向かうためにどうすれば良いのでしょうか.


ソフトウェア工学では, しばしば建築学の話が登場します.

ただし, 大きな違いを1つ挙げるとすると, 建物は経年劣化でいずれ壊れるのに対して,

ソフトウェアのプログラムは記憶装置の故障でもない限り, 自然と壊れることはないという点です.

そして, プログラムが壊れる原因はいつも"開発者の変更"によるものだということです.


総ファイル数10億, コード20億行, 1日のコミット数4万回以上のプロジェクトをご存知でしょうか.

開発者として, この巨大プロジェクトで働くことを想像してみて下さい.


市場では数十億のユーザがこのソフトウェアを使い, 新しい機能を待ち望んでいます.

バグの解決を待ち望んでいるユーザも少なくありません.

あなたはこの巨大なソフトウェアに新たな価値を追加し, バグを修正する必要もあります.

つまり, "このソフトウェアをうまく変更しろ"というわけです.

もちろん, "既にあるプログラムを壊すことなく"という前提条件付きです.


私たち開発者は, 時にソフトウェアの変更に対して恐怖を抱くことがあります.

複雑に絡み合った, 理解しがたく, どれだけ調べても確証の得られないソフトウェアの変更は,

命綱なしで空中ブランコをやるようなものです.

"成功しますように"と祈りながらリリースすることになります.


残念ながら, 命綱が欲しいと思う一方で, それを探しもせず毎日苦しい思いをして,

祈りながら, 時には大怪我を負いながら頑張っている開発者がほとんどです.


先ほど紹介した巨大プロジェクトの名は"Google"です.

では, Googleのエンジニア達はソフトウェアの複雑さを物ともしない集団なのでしょうか.

あるいは, 命綱なしの空中ブランコを楽しめる狂人揃いなのでしょうか.

答えはどちらも"No"です.


Googleのエンジニア達も私たちと変わらず, 同じように"大きな象"と闘っています.

ただ, 彼・彼女らには命綱があるからこそ, 1日に4万回以上もの変更をやってのけることができるのです.


では, ソフトウェア開発における"命綱"とは何でしょうか.

皆さんの開発フェーズにもおそらく"回帰(リグレッション)テスト"のフェーズがあることでしょう.

回帰テストの目的は, プログラムの変更が予想外の影響を及ぼしていないかどうかを確認することです.


回帰テストの実施は良い考えです.

しかし, 回帰テストと聞くと"アプリケーションインタフェースに対して実施するもの"と考えられがちです.

そこにはいくつかの問題があります.


 1. エラー箇所の特定...テストがテスト対象から離れすぎて, テストの失敗が何を意味しているのかの判断が難しい

 2. 実行時間...巨大なテストはコストがかさみ, 実行時間も長くなるため頻繁に実施されない

 3. カバレッジ...新しく追加したコードを動かす高次のテストを書くために, かなりの作業が必要になる


これは非常に残念なことです.

回帰テストから得られるフィードバックは有益なため, もっと細かいレベルで頻繁に行う価値があります.

これらの問題はクラスやメソッドといった粒度で回帰テストを実施すれば解消できるのです.


回帰テストは, 見方を変えると"ソフトウェアが壊れていないか"を確認するテストとも言えます.

あなたがソフトウェアを変更した際に, 自分の変更がソフトウェアを壊していないかどうかを確認できるのです.

これがエンジニアを救う心強い存在になることは明らかです.

価値のある回帰テストは"炭鉱のカナリア"として"大きな象"に立ち向かう心強い仲間となってくれるのです.


火星探査機のスピリットをご存知でしょうか.

正式名称マーズ・エクスプロレーション・ローバーAは、マーズ・エクスプロレーション・ローバー計画でオポチュニティと共に火星に送られた無人探査機の一つです.

スピリットは写真を撮りながら火星の表面をゆっくりと進んでいます.

地球から送った信号を受け取るのにかかる時間は約7分です.

例えば, 火星にいるスピリットを地球から手動操作することを想像してみてください.

探査機の操作を行い, どれぐらい動いたかを確認できるのは.およそ14分後になります.

それから次に行うことを決定して, それを実行し, そして何が起こったかを理解するのに, また14分待たなくてはいけません.

これはバカバカしいほどに非効率です.


皆さんのプロジェクトでは, ソフトウェアを変更した際に, それがうまくいったかどうかのフィードバックを得るのにかかる時間は

スピリットの例より長いでしょうか, 短いでしょうか.

"フィードバックにかかる時間"というのは思っている以上に重要な要素です.

素早いフィードバックは誤りを直ちに修正させ, 無駄を最小限にとどめます.

遅いフィードバックはエンジニアをうんざりさせて, もはやテストは実施されなくなります.


細かいレベルで行われる回帰テストは何百, 何千, 規模によっては数千万にもなるテストケースで構成されます.

テストケース1つの実行にかける時間は0.1秒未満が原則です.

炭鉱のカナリアが鳴き始めるのに数日かかるようでは遅すぎます.

価値のある回帰テストには素早いフィードバックが必要不可欠なのです.


大きな象と闘うためには素早いフィードバックスキルを備えたカナリアを仲間にする必要があります.

味方にする方法は, より細かく, 価値のある回帰テストを自動化することです.

テスト自動化というと, 品質の安定や効率化に目を奪われがちですが, エンジニアの精神安定剤としての効果が大きいのです.

変化が求められる昨今, ソフトウェアの変更容易性が市場で成功する１つの鍵になっています.


第二回developer meetupではテスト自動化に取り組みます.

テスト駆動によるフィードバックループがはじまると, 今までとは違ったソフトウェア開発の姿が見えてきます.

"カナリア"を仲間にしたい人は是非ご参加ください.




参考:

 - Rails conf 2012 - Simplicity matters(Rich Hickey)

 - レガシーコード改善ガイド(Michael Feathers)


* Googleプロジェクトについて. 実際に人の手によるコミットは1万回, 残る3万回は自動化システムによるもの

* 象の成長速度を抑える方法もあります. より良い方法はソフトウェアを"シンプルにたもつ"こと

* 火星探査機スピリットについて. スピリットには自動誘導ソフトウェアが搭載されている

